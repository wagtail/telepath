{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"telepath telepath is a Django library for exchanging data between Python and JavaScript, allowing you to build apps with rich client-side interfaces while keeping the business logic in server-side code. What does it do? It provides a mechanism for packing structured data, including Python objects, into a JSON-serializable format. This mechanism can be extended to support any Python class, by registering the class with a corresponding JavaScript implementation. The packed data can then be included in an HTTP response, and unpacked in JavaScript to obtain an equivalent data structure to the original. Think of it as pickle , but with the unpickling happening in the browser. Installation To install: pip install telepath and add 'telepath' to your project's INSTALLED_APPS .","title":"Home"},{"location":"#telepath","text":"telepath is a Django library for exchanging data between Python and JavaScript, allowing you to build apps with rich client-side interfaces while keeping the business logic in server-side code.","title":"telepath"},{"location":"#what-does-it-do","text":"It provides a mechanism for packing structured data, including Python objects, into a JSON-serializable format. This mechanism can be extended to support any Python class, by registering the class with a corresponding JavaScript implementation. The packed data can then be included in an HTTP response, and unpacked in JavaScript to obtain an equivalent data structure to the original. Think of it as pickle , but with the unpickling happening in the browser.","title":"What does it do?"},{"location":"#installation","text":"To install: pip install telepath and add 'telepath' to your project's INSTALLED_APPS .","title":"Installation"},{"location":"adapters/","text":"Packing objects from external packages Sometimes it may be necessary to pack objects that are defined by the Python standard library or a third-party package such as Django. In this case, adding a telepath_pack method as described earlier is not an option, since the class definition exists outside of your own code. To accommodate this, telepath allows you to define the packing logic in an Adapter object, and register this so that it is used whenever an object of the given type is encountered. For example, suppose we want to be able to pack datetime.time instances. This can be done as follows: import datetime from telepath import Adapter , register class TimeAdapter ( Adapter ): def pack ( self , obj , context ): context . add_media ( js = 'datetime.js' ) return ( 'datetime.Time' , [ obj . hour , obj . minute , obj . second ]) register ( TimeAdapter (), datetime . time ) The pack method here works in the same way as a telepath_pack method on the class itself, except that the object is passed as an argument rather than operating on self . The resulting TimeAdapter object is then passed to register to be used for datetime.time instances. On the JavaScript side, the datetime.Time constructor can then be defined and registered in the same way as before. In datetime.js : class Time { constructor ( hour , minute , second ) { this . hour = hour ; this . minute = minute ; this . second = second ; } toString () { return ( this . hour . toString (). padStart ( 2 , '0' ) + ':' + this . minute . toString (). padStart ( 2 , '0' ) + ':' + this . second . toString (). padStart ( 2 , '0' ) ); } } window . telepath . register ( 'datetime.Time' , Time );","title":"Packing external objects"},{"location":"adapters/#packing-objects-from-external-packages","text":"Sometimes it may be necessary to pack objects that are defined by the Python standard library or a third-party package such as Django. In this case, adding a telepath_pack method as described earlier is not an option, since the class definition exists outside of your own code. To accommodate this, telepath allows you to define the packing logic in an Adapter object, and register this so that it is used whenever an object of the given type is encountered. For example, suppose we want to be able to pack datetime.time instances. This can be done as follows: import datetime from telepath import Adapter , register class TimeAdapter ( Adapter ): def pack ( self , obj , context ): context . add_media ( js = 'datetime.js' ) return ( 'datetime.Time' , [ obj . hour , obj . minute , obj . second ]) register ( TimeAdapter (), datetime . time ) The pack method here works in the same way as a telepath_pack method on the class itself, except that the object is passed as an argument rather than operating on self . The resulting TimeAdapter object is then passed to register to be used for datetime.time instances. On the JavaScript side, the datetime.Time constructor can then be defined and registered in the same way as before. In datetime.js : class Time { constructor ( hour , minute , second ) { this . hour = hour ; this . minute = minute ; this . second = second ; } toString () { return ( this . hour . toString (). padStart ( 2 , '0' ) + ':' + this . minute . toString (). padStart ( 2 , '0' ) + ':' + this . second . toString (). padStart ( 2 , '0' ) ); } } window . telepath . register ( 'datetime.Time' , Time );","title":"Packing objects from external packages"},{"location":"api_reference/","text":"API reference Python API telepath.Adapter() Base class for an adapter object, which defines how telepath should handle a particular Python type. Subclasses should define the following method: pack(obj, context) - Returns a 'deconstructed' version of the object obj , consisting of the data necessary to reconstruct it in JavaScript. This should be a tuple (identifier, args) : identifier - the identifier for a JavaScript constructor function that will be registered with the JavaScript register method; this constructor function will be called when an object of this type is encountered in the data. This identifier should be unique among all adapter objects registered; it is recommended to use a namespaced string with dots as separators (e.g. 'myproject.animals.Cat' ). args - the list of arguments that should be passed to the constructor function to recreate the corresponding client-side object. The arguments must themselves be telepath-packable values (i.e. basic JSON-serialisable types, or objects with a telepath adapter defined). The context argument allows the adapter to specify JavaScript and CSS assets that must be included on the client-side page when unpacking the object; at minimum, this should include the JavaScript file that defines and registers the constructor function returned from pack . The context object defines the method: context.add_media(media=None, js=None, css=None) - adds a media definition to include on the client-side page. This can be any of the following: a Django form media object , a single JavaScript file path, a list of JavaScript file paths, and/or a dict of CSS file paths where the key is a media type (i.e. the same convention as used in form media objects). Alternative adapter API (deprecated) As an alternative to defining pack , adapter subclasses may define the following: js_constructor - The identifier for a JavaScript constructor function, as above. js_args(obj) - Given the object to be packed, return the list of arguments that should be passed to the constructor function. get_media(obj) - Given the object to be packed, return a Django form media object for the JavaScript and CSS assets needed to unpack the client-side object. This should include the .js file where the constructor function is defined and registered with telepath. Alternatively, if the media definition is the same for all object instances, this can be defined as an inner Media class. telepath.AutoAdapter() A general-purpose adapter object for classes that define their own packing logic; this is generally the preferred route when making classes you have defined yourself available to telepath, as it is more concise than defining an adapter object explicitly. The class must implement a method telepath_pack(self, context) ; AutoAdapter will delegate to this when packing the object. telepath.register(adapter, cls) Registers an adapter object (an instance of a telepath.Adapter subclass) to be used by telepath when it encounters an object of type cls . If more than one class in an object's inheritance chain has an adapter defined, the most specific one according to the method resolution order (MRO) will be used. Can also be applied as a class decorator @telepath.register(adapter=MyAdapter()) ; in this case adapter is optional and defaults to AutoAdapter() if not specified. telepath.JSContext() An object for handling all packing operations for a particular request. Provides the following methods and attributes: pack(obj) - Returns the packed representation of the given object. This representation is a value that can be serialised as JSON and included in an HTTP response; on the client side this can then be deserialised with JSON.parse and passed to telepath.unpack to obtain the unpacked object. media - A Django form media object listing the JavaScript and CSS assets needed to unpack all objects that have been passed to pack . This object should be rendered into a template response to ensure that the client-side telepath.unpack operation has all the necessary definitions. telepath.AdapterRegistry(telepath_js_path='telepath/js/telepath.js') An object that manages a set of adapter objects to be used collectively for packing values. Normally you will not need to work with this class directly, as the telepath module maintains a global set of adapters that are registered with the top-level register function and used by JSContext ; however, in some cases it may be useful to build a 'local' registry of adapters with different behaviour from the global set, such as serving media from a custom application-specific path. Provides the method register(adapter, cls) which is equivalent to the top-level register function, and the property js_context_class which returns a class equivalent to JSContext that uses this local registry when packing values. The optional telepath_js_path argument specifies the path to telepath.js to be used in this object's media definitions. JavaScript API window.telepath An object that manages unpacking values. Provides the following methods: register(name, constructor) - Registers a constructor function to be used when unpacking. The name argument should match the identifier given as js_constructor for an adapter object. unpack(val) - Unpacks the packed telepath data representation into a native JavaScript object.","title":"API reference"},{"location":"api_reference/#api-reference","text":"","title":"API reference"},{"location":"api_reference/#python-api","text":"","title":"Python API"},{"location":"api_reference/#telepathadapter","text":"Base class for an adapter object, which defines how telepath should handle a particular Python type. Subclasses should define the following method: pack(obj, context) - Returns a 'deconstructed' version of the object obj , consisting of the data necessary to reconstruct it in JavaScript. This should be a tuple (identifier, args) : identifier - the identifier for a JavaScript constructor function that will be registered with the JavaScript register method; this constructor function will be called when an object of this type is encountered in the data. This identifier should be unique among all adapter objects registered; it is recommended to use a namespaced string with dots as separators (e.g. 'myproject.animals.Cat' ). args - the list of arguments that should be passed to the constructor function to recreate the corresponding client-side object. The arguments must themselves be telepath-packable values (i.e. basic JSON-serialisable types, or objects with a telepath adapter defined). The context argument allows the adapter to specify JavaScript and CSS assets that must be included on the client-side page when unpacking the object; at minimum, this should include the JavaScript file that defines and registers the constructor function returned from pack . The context object defines the method: context.add_media(media=None, js=None, css=None) - adds a media definition to include on the client-side page. This can be any of the following: a Django form media object , a single JavaScript file path, a list of JavaScript file paths, and/or a dict of CSS file paths where the key is a media type (i.e. the same convention as used in form media objects).","title":"telepath.Adapter()"},{"location":"api_reference/#alternative-adapter-api-deprecated","text":"As an alternative to defining pack , adapter subclasses may define the following: js_constructor - The identifier for a JavaScript constructor function, as above. js_args(obj) - Given the object to be packed, return the list of arguments that should be passed to the constructor function. get_media(obj) - Given the object to be packed, return a Django form media object for the JavaScript and CSS assets needed to unpack the client-side object. This should include the .js file where the constructor function is defined and registered with telepath. Alternatively, if the media definition is the same for all object instances, this can be defined as an inner Media class.","title":"Alternative adapter API (deprecated)"},{"location":"api_reference/#telepathautoadapter","text":"A general-purpose adapter object for classes that define their own packing logic; this is generally the preferred route when making classes you have defined yourself available to telepath, as it is more concise than defining an adapter object explicitly. The class must implement a method telepath_pack(self, context) ; AutoAdapter will delegate to this when packing the object.","title":"telepath.AutoAdapter()"},{"location":"api_reference/#telepathregisteradapter-cls","text":"Registers an adapter object (an instance of a telepath.Adapter subclass) to be used by telepath when it encounters an object of type cls . If more than one class in an object's inheritance chain has an adapter defined, the most specific one according to the method resolution order (MRO) will be used. Can also be applied as a class decorator @telepath.register(adapter=MyAdapter()) ; in this case adapter is optional and defaults to AutoAdapter() if not specified.","title":"telepath.register(adapter, cls)"},{"location":"api_reference/#telepathjscontext","text":"An object for handling all packing operations for a particular request. Provides the following methods and attributes: pack(obj) - Returns the packed representation of the given object. This representation is a value that can be serialised as JSON and included in an HTTP response; on the client side this can then be deserialised with JSON.parse and passed to telepath.unpack to obtain the unpacked object. media - A Django form media object listing the JavaScript and CSS assets needed to unpack all objects that have been passed to pack . This object should be rendered into a template response to ensure that the client-side telepath.unpack operation has all the necessary definitions.","title":"telepath.JSContext()"},{"location":"api_reference/#telepathadapterregistrytelepath_js_pathtelepathjstelepathjs","text":"An object that manages a set of adapter objects to be used collectively for packing values. Normally you will not need to work with this class directly, as the telepath module maintains a global set of adapters that are registered with the top-level register function and used by JSContext ; however, in some cases it may be useful to build a 'local' registry of adapters with different behaviour from the global set, such as serving media from a custom application-specific path. Provides the method register(adapter, cls) which is equivalent to the top-level register function, and the property js_context_class which returns a class equivalent to JSContext that uses this local registry when packing values. The optional telepath_js_path argument specifies the path to telepath.js to be used in this object's media definitions.","title":"telepath.AdapterRegistry(telepath_js_path='telepath/js/telepath.js')"},{"location":"api_reference/#javascript-api","text":"","title":"JavaScript API"},{"location":"api_reference/#windowtelepath","text":"An object that manages unpacking values. Provides the following methods: register(name, constructor) - Registers a constructor function to be used when unpacking. The name argument should match the identifier given as js_constructor for an adapter object. unpack(val) - Unpacks the packed telepath data representation into a native JavaScript object.","title":"window.telepath"},{"location":"data_format/","text":"Data format The data format used internally by telepath allows arbitrary objects to be represented as JSON-serialisable data structures. Data is unpacked by recursively descending the JSON-parsed data structure; certain dict (object) values are designated as special cases by the presence of any of the following reserved key names: \"_type\" , \"_args\" , \"_id\" , \"_ref\" , \"_dict\" , \"_list\" , \"_val\" . Arrays, and dict values that do not contain any reserved key names, are handled by recursively unpacking their child elements; all other values (strings, numbers, booleans and null ) are left unchanged. The reserved key names have the following meanings: _type Represents an object that needs to be instantiated using a constructor function. The value of _type is a string identifier for a constructor function that has been registered with telepath.register . This dict will also have an _args item giving a list of arguments to be passed to the function; values in this list will be recursively unpacked before being passed to the constructor. For example, if the function (or class) Dog(name, breed) has been registered with telepath.register('myproject.animals.Dog', Dog) , then the dict {\"_type\": \"myproject.animals.Dog\", \"_args\": [\"Lassie\", \"collie\"]} will be unpacked to the result of new Dog(\"Lassie\", \"collie\") . _id Assigns a numeric identifier to the unpacked object, to be referenced elsewhere using _ref ; this allows one object instance to appear multiple times in the unpacked data structure. _ref Represents an object that has been defined elsewhere in the data structure and assigned an identifier via _id . For example, if the function Kennel(allDogs, dogsByName, dogsByBreed) has been registered under the name myproject.homes.Kennel , then the dict: {\"_type\": \"myproject.homes.Kennel\", \"_args\": [ [{\"_type\": \"myproject.animals.Dog\", \"_args\": [\"Lassie\", \"collie\"], \"_id\": 1}], {\"Lassie\": {\"_ref\": 1}}, {\"collie\": {\"_ref\": 1}} ]} will be unpacked by first evaluating new Dog(\"Lassie\", \"collie\") as above, then passing that same object instance in all three arguments of Kennel . Note that forward references are valid; _ref may reference an _id identifier that appears later in the serialised data stream. _dict Represents a dict (object) value. For example: {\"_dict\": {\"a\": 1, \"b\": 2}} is equivalent to {\"a\": 1, \"b\": 2} . As with the short form, values in the dict will be unpacked recursively. In practice, the long-form _dict representation will be used in one of two situations: When the dict keys include reserved names that should be handled literally: for example, {\"_dict\": {\"_name\": \"Lassie\", \"_type\": \"collie\"}} will evaluate to the dict {\"_name\": \"Lassie\", \"_type\": \"collie\"} and not attempt to interpret \"_type\": \"collie\" as a constructor function. When an _id identifier needs to be attached to the dict: for example, a dict defined as {\"_dict\": {\"a\": 1, \"b\": 2}, \"_id\": 2} can be referenced elsewhere as {\"_ref\": 2} . _list Represents a list (array) value. For example: {\"_list\": [1, 2, 3]} is equivalent to [1, 2, 3] . As with the short form, elements in the list will be unpacked recursively. In practice, the long-form _list representation will only be used when an _id identifier needs to be attached to it: for example, a list defined as {\"_list\": [1, 2, 3], \"_id\": 3} can be referenced elsewhere as {\"_ref\": 3} . _val Represents a primitive value that does not need to be expanded further. For example: {\"_val\": \"hello world\"} is equivalent to \"hello world\" . In practice, the long-form _list representation will only be used when an _id identifier needs to be attached to it: for example, a string defined as {\"_val\": \"hello world\", \"_id\": 4} can be referenced elsewhere as {\"_id\": 4} .","title":"Data format"},{"location":"data_format/#data-format","text":"The data format used internally by telepath allows arbitrary objects to be represented as JSON-serialisable data structures. Data is unpacked by recursively descending the JSON-parsed data structure; certain dict (object) values are designated as special cases by the presence of any of the following reserved key names: \"_type\" , \"_args\" , \"_id\" , \"_ref\" , \"_dict\" , \"_list\" , \"_val\" . Arrays, and dict values that do not contain any reserved key names, are handled by recursively unpacking their child elements; all other values (strings, numbers, booleans and null ) are left unchanged. The reserved key names have the following meanings:","title":"Data format"},{"location":"data_format/#_type","text":"Represents an object that needs to be instantiated using a constructor function. The value of _type is a string identifier for a constructor function that has been registered with telepath.register . This dict will also have an _args item giving a list of arguments to be passed to the function; values in this list will be recursively unpacked before being passed to the constructor. For example, if the function (or class) Dog(name, breed) has been registered with telepath.register('myproject.animals.Dog', Dog) , then the dict {\"_type\": \"myproject.animals.Dog\", \"_args\": [\"Lassie\", \"collie\"]} will be unpacked to the result of new Dog(\"Lassie\", \"collie\") .","title":"_type"},{"location":"data_format/#_id","text":"Assigns a numeric identifier to the unpacked object, to be referenced elsewhere using _ref ; this allows one object instance to appear multiple times in the unpacked data structure.","title":"_id"},{"location":"data_format/#_ref","text":"Represents an object that has been defined elsewhere in the data structure and assigned an identifier via _id . For example, if the function Kennel(allDogs, dogsByName, dogsByBreed) has been registered under the name myproject.homes.Kennel , then the dict: {\"_type\": \"myproject.homes.Kennel\", \"_args\": [ [{\"_type\": \"myproject.animals.Dog\", \"_args\": [\"Lassie\", \"collie\"], \"_id\": 1}], {\"Lassie\": {\"_ref\": 1}}, {\"collie\": {\"_ref\": 1}} ]} will be unpacked by first evaluating new Dog(\"Lassie\", \"collie\") as above, then passing that same object instance in all three arguments of Kennel . Note that forward references are valid; _ref may reference an _id identifier that appears later in the serialised data stream.","title":"_ref"},{"location":"data_format/#_dict","text":"Represents a dict (object) value. For example: {\"_dict\": {\"a\": 1, \"b\": 2}} is equivalent to {\"a\": 1, \"b\": 2} . As with the short form, values in the dict will be unpacked recursively. In practice, the long-form _dict representation will be used in one of two situations: When the dict keys include reserved names that should be handled literally: for example, {\"_dict\": {\"_name\": \"Lassie\", \"_type\": \"collie\"}} will evaluate to the dict {\"_name\": \"Lassie\", \"_type\": \"collie\"} and not attempt to interpret \"_type\": \"collie\" as a constructor function. When an _id identifier needs to be attached to the dict: for example, a dict defined as {\"_dict\": {\"a\": 1, \"b\": 2}, \"_id\": 2} can be referenced elsewhere as {\"_ref\": 2} .","title":"_dict"},{"location":"data_format/#_list","text":"Represents a list (array) value. For example: {\"_list\": [1, 2, 3]} is equivalent to [1, 2, 3] . As with the short form, elements in the list will be unpacked recursively. In practice, the long-form _list representation will only be used when an _id identifier needs to be attached to it: for example, a list defined as {\"_list\": [1, 2, 3], \"_id\": 3} can be referenced elsewhere as {\"_ref\": 3} .","title":"_list"},{"location":"data_format/#_val","text":"Represents a primitive value that does not need to be expanded further. For example: {\"_val\": \"hello world\"} is equivalent to \"hello world\" . In practice, the long-form _list representation will only be used when an _id identifier needs to be attached to it: for example, a string defined as {\"_val\": \"hello world\", \"_id\": 4} can be referenced elsewhere as {\"_id\": 4} .","title":"_val"},{"location":"primitive_adapters/","text":"Packing objects to primitive values In some cases, rather than writing a custom JavaScript class to correspond to a Python object, it's more appropriate for the JavaScript representation to be a primitive value such as a number or string. For example, Django's lazy translatable string objects behave as strings for the most part, but contain custom Python-side logic to ensure that the correct translation for the active locale is chosen. This logic is not relevant to client-side code, and so it is appropriate for the JavaScript code to receive that object as a plain string. (In fact, telepath has built-in recognition for lazy translation strings; however, other Python code may use a similar mechanism and need special treatment.) For this purpose, telepath provides the classes StringAdapter (for string values) and BaseAdapter (for other simple types) which can be subclassed, and registered in the same way as the adapters we saw previously. For example, if our Python code defines a class for managing capitalised strings: class StringLike (): def __init__ ( self , val ): self . val = val . upper () def __str__ ( self ): return self . val we can define and register an adapter that will return plain strings when unpacked on the JavaScript side, as follows: from telepath import StringAdapter , register class StringLikeAdapter ( StringAdapter ): def build_node ( self , obj , context ): return super () . build_node ( str ( obj ), context ) register ( StringLikeAdapter (), StringLike ) Note that the first argument passed to super().build_node must be of the correct type - a string for StringAdapter , or any JSON-serializable value for BaseAdapter .","title":"Packing objects to primitive values"},{"location":"primitive_adapters/#packing-objects-to-primitive-values","text":"In some cases, rather than writing a custom JavaScript class to correspond to a Python object, it's more appropriate for the JavaScript representation to be a primitive value such as a number or string. For example, Django's lazy translatable string objects behave as strings for the most part, but contain custom Python-side logic to ensure that the correct translation for the active locale is chosen. This logic is not relevant to client-side code, and so it is appropriate for the JavaScript code to receive that object as a plain string. (In fact, telepath has built-in recognition for lazy translation strings; however, other Python code may use a similar mechanism and need special treatment.) For this purpose, telepath provides the classes StringAdapter (for string values) and BaseAdapter (for other simple types) which can be subclassed, and registered in the same way as the adapters we saw previously. For example, if our Python code defines a class for managing capitalised strings: class StringLike (): def __init__ ( self , val ): self . val = val . upper () def __str__ ( self ): return self . val we can define and register an adapter that will return plain strings when unpacked on the JavaScript side, as follows: from telepath import StringAdapter , register class StringLikeAdapter ( StringAdapter ): def build_node ( self , obj , context ): return super () . build_node ( str ( obj ), context ) register ( StringLikeAdapter (), StringLike ) Note that the first argument passed to super().build_node must be of the correct type - a string for StringAdapter , or any JSON-serializable value for BaseAdapter .","title":"Packing objects to primitive values"},{"location":"tutorial/","text":"Tutorial Suppose we're building a Django app for playing draughts (checkers). We've hammered away for days or weeks, building a Python implementation of the rules of the game, with classes to represent the current game state and the individual pieces. However, we also want to provide the player with a suitably friendly user interface, which means it's time for us to write a JavaScript front-end. Our UI code is inevitably going to have its own objects representing the board and playing pieces, mirroring the data structures we're keeping track of on the server - but we can't send Python objects down the wire, so getting that data onto the client will typically mean devising a JSON representation of the game state, and a whole lot of boilerplate code at either end, looping over data structures to convert to and from native objects. Let's see how telepath can streamline that process. A full game of draughts is a bit much for a tutorial, so we'll settle for just rendering the board instead... From a clean Python environment, create a new Django project: pip install \"Django>=3.1,<3.2\" django-admin startproject draughts cd draughts ./manage.py startapp games Add 'games', to the INSTALLED_APPS list in draughts/settings.py . To keep things simple, we won't touch the database in this example, and will represent the game state as ordinary Python classes rather than Django models. Edit games/views.py as follows: from django.shortcuts import render class Piece : def __init__ ( self , color , position ): self . color = color self . position = position class GameState : def __init__ ( self , pieces ): self . pieces = pieces @staticmethod def new_game (): black_pieces = [ Piece ( 'black' , ( x , y )) for y in range ( 0 , 3 ) for x in range (( y + 1 ) % 2 , 8 , 2 ) ] white_pieces = [ Piece ( 'white' , ( x , y )) for y in range ( 5 , 8 ) for x in range (( y + 1 ) % 2 , 8 , 2 ) ] return GameState ( black_pieces + white_pieces ) def game ( request ): game_state = GameState . new_game () return render ( request , 'game.html' , {}) Create games/templates/game.html as follows: <!doctype html> < html > < head > < title > Draughts </ title > < script > document . addEventListener ( 'DOMContentLoaded' , event => { const gameElement = document . getElementById ( 'game' ); gameElement . innerHTML = 'TODO: render the board here' }); </ script > </ head > < body > < h1 > Draughts </ h1 > < div id = \"game\" > </ div > </ body > </ html > Add the new view to draughts/urls.py : from django.contrib import admin from django.urls import path from games.views import game urlpatterns = [ path ( '' , game ), path ( 'admin/' , admin . site . urls ), ] Now start the server with ./manage.py runserver and visit http://localhost:8000/ . So far we've created a GameState object representing a new game - it's now time to introduce telepath, so that we can transfer that object to the client. Run: pip install telepath and add 'telepath', to the INSTALLED_APPS list in draughts/settings.py . Now edit games/views.py : import json from django.shortcuts import render from telepath import JSContext # ... def game ( request ): game_state = GameState . new_game () js_context = JSContext () packed_game_state = js_context . pack ( game_state ) game_state_json = json . dumps ( packed_game_state ) return render ( request , 'game.html' , { 'game_state_json' : game_state_json , }) Here JSContext is a helper that manages the conversion of our game state object into a representation we can use in Javascript. js_context.pack takes that object and converts it to a value that can be JSON-serialised and passed to our template. However, reloading the page now fails with an error of the form: don't know how to pack object: <games.views.GameState object at 0x10f3f2490> This is because GameState is a custom Python type that telepath does not yet know how to handle. Any custom type passed to pack must be linked to a corresponding JavaScript implementation; this is done by defining a telepath_pack method and registering the class with telepath. Update games/views.py as follows: import json from django.shortcuts import render from telepath import JSContext , register # ... @register class GameState : def __init__ ( self , pieces ): self . pieces = pieces @staticmethod def new_game (): black_pieces = [ Piece ( 'black' , ( x , y )) for y in range ( 0 , 3 ) for x in range (( y + 1 ) % 2 , 8 , 2 ) ] white_pieces = [ Piece ( 'white' , ( x , y )) for y in range ( 5 , 8 ) for x in range (( y + 1 ) % 2 , 8 , 2 ) ] return GameState ( black_pieces + white_pieces ) def telepath_pack ( self , context ): context . add_media ( js = 'draughts.js' ) return ( 'draughts.GameState' , [ self . pieces ]) Here the telepath_pack method tells telepath how to 'deconstruct' the game_state object so that it can be reconstructed on the client side as a JavaScript object. 'draughts.GameState' is an identifier for a JavaScript constructor function that we will define later on; this is followed by a list of arguments that will be passed to this constructor function, which in this case is a single argument, the list of Piece objects. The line context.add_media(js='draughts.js']) tells telepath that the JavaScript implementation of GameState can be found in the file draughts.js . We'll see what this JavaScript implementation looks like later - for now, we need to add a similar definition for our Piece class, since our definition of GameState.telepath_pack is dependent on being able to pack Piece instances. In games/views.py : @register class Piece : def __init__ ( self , color , position ): self . color = color self . position = position def telepath_pack ( self , context ): context . add_media ( js = 'draughts.js' ) return ( 'draughts.Piece' , [ self . color , self . position ]) Reload the page and you'll see that the error has gone, indicating that we have successfully serialised the GameState object to JSON and passed it to the template. We can now include this in the template - edit games/templates/game.html : < body > < h1 > Draughts </ h1 > < div id = \"game\" data-game-state = \"{{ game_state_json }}\" > </ div > </ body > Reload the page again and inspect the game element in your browser's developer tools (in Chrome and Firefox, right-click the TODO note and select Inspect or Inspect Element), and you'll see the JSON representation of the GameState object, ready to be unpacked into a full-fledged JavaScript object. Along with packing data into JSON-serialisable form, the JSContext object also keeps track of the JavaScript media definitions that will be needed to unpack the data, as its media property. Let's update our game view to pass this to the template too - in games/views.py : def game ( request ): game_state = GameState . new_game () js_context = JSContext () packed_game_state = js_context . pack ( game_state ) game_state_json = json . dumps ( packed_game_state ) return render ( request , 'game.html' , { 'game_state_json' : game_state_json , 'media' : js_context . media , }) Add this to the HTML header in games/templates/game.html : < head > < title > Draughts </ title > {{ media }} < script > document . addEventListener ( 'DOMContentLoaded' , event => { const gameElement = document . getElementById ( 'game' ); gameElement . innerHTML = 'TODO: render the board here' }); </ script > </ head > Reloading the page and viewing source, you'll see that this brings in two JavaScript includes - telepath.js (the client-side telepath library, which provides the unpacking mechanism) and the draughts.js file we specified in our telepath_pack methods. The latter doesn't exist yet, so let's create it - in games/static/draughts.js : class Piece { constructor ( color , position ) { this . color = color ; this . position = position ; } } window . telepath . register ( 'draughts.Piece' , Piece ); class GameState { constructor ( pieces ) { this . pieces = pieces ; } } window . telepath . register ( 'draughts.GameState' , GameState ); The two class definitions implement the constructor functions that we declared earlier in the telepath_pack methods - the arguments received by the constructor match the ones we supplied in the pack method. The window.telepath.register lines attach these class definitions to the corresponding identifiers that were specified through js_constructor . This now gives us everything we need to unpack the JSON - back in games/templates/game.html , update the JS code as follows: < script > document . addEventListener ( 'DOMContentLoaded' , event => { const gameElement = document . getElementById ( 'game' ); const gameStateJson = gameElement . dataset . gameState ; const packedGameState = JSON . parse ( gameStateJson ); const gameState = window . telepath . unpack ( packedGameState ); console . log ( gameState ); }) </ script > You may need to restart the server to pick up the new games/static folder. Reload the page, and in the browser console you should now see the GameState object, populated with Piece objects. We can now proceed to fill in our rendering code in games/static/draughts.js : class Piece { constructor ( color , position ) { this . color = color ; this . position = position ; } render ( container ) { const element = document . createElement ( 'div' ); container . appendChild ( element ); element . style . width = element . style . height = '24px' ; element . style . border = '2px solid grey' ; element . style . borderRadius = '14px' ; element . style . backgroundColor = this . color ; } } window . telepath . register ( 'draughts.Piece' , Piece ) class GameState { constructor ( pieces ) { this . pieces = pieces ; } render ( container ) { const table = document . createElement ( 'table' ); container . appendChild ( table ); const cells = []; for ( let y = 0 ; y < 8 ; y ++ ) { let row = document . createElement ( 'tr' ); table . appendChild ( row ); cells [ y ] = []; for ( let x = 0 ; x < 8 ; x ++ ) { let cell = document . createElement ( 'td' ); row . appendChild ( cell ); cells [ y ][ x ] = cell ; cell . style . width = cell . style . height = '32px' ; cell . style . backgroundColor = ( x + y ) % 2 ? 'silver' : 'white' ; } } this . pieces . forEach ( piece => { const [ x , y ] = piece . position ; const cell = cells [ y ][ x ]; piece . render ( cell ); }); } } window . telepath . register ( 'draughts.GameState' , GameState ) Add a call to the render method in games/templates/game.html : < script > document . addEventListener ( 'DOMContentLoaded' , event => { const gameElement = document . getElementById ( 'game' ); const gameStateJson = gameElement . dataset . gameState ; const packedGameState = JSON . parse ( gameStateJson ); const gameState = window . telepath . unpack ( packedGameState ); gameState . render ( gameElement ); }) </ script > Reload the page, and you'll see our draughts board set up and ready for a game. Let's take a quick look back at what we've achieved: We've packed and unpacked a data structure of custom Python / JavaScript types, without having to write code to recurse over that structure. If our GameState object becomes more complex (for example, the 'pieces' list might become a mixed list of Piece and King objects, or the state could include the game history) then there's no need to refactor any of the data packing / unpacking logic, other than registering each class with a telepath_pack method. Only the JS files necessary for unpacking the on-page data were served - if our gaming app expanded to cover Chess, Go and Othello, with all of the resulting classes registered with telepath, we'd still only need to serve the draughts-related code on this page. Even though we're working with arbitrary objects, no dynamic inline JavaScript was required - all dynamic data was passed as JSON, and all JavaScript code was fixed at deployment time (important if our site is enforcing CSP ).","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"Suppose we're building a Django app for playing draughts (checkers). We've hammered away for days or weeks, building a Python implementation of the rules of the game, with classes to represent the current game state and the individual pieces. However, we also want to provide the player with a suitably friendly user interface, which means it's time for us to write a JavaScript front-end. Our UI code is inevitably going to have its own objects representing the board and playing pieces, mirroring the data structures we're keeping track of on the server - but we can't send Python objects down the wire, so getting that data onto the client will typically mean devising a JSON representation of the game state, and a whole lot of boilerplate code at either end, looping over data structures to convert to and from native objects. Let's see how telepath can streamline that process. A full game of draughts is a bit much for a tutorial, so we'll settle for just rendering the board instead... From a clean Python environment, create a new Django project: pip install \"Django>=3.1,<3.2\" django-admin startproject draughts cd draughts ./manage.py startapp games Add 'games', to the INSTALLED_APPS list in draughts/settings.py . To keep things simple, we won't touch the database in this example, and will represent the game state as ordinary Python classes rather than Django models. Edit games/views.py as follows: from django.shortcuts import render class Piece : def __init__ ( self , color , position ): self . color = color self . position = position class GameState : def __init__ ( self , pieces ): self . pieces = pieces @staticmethod def new_game (): black_pieces = [ Piece ( 'black' , ( x , y )) for y in range ( 0 , 3 ) for x in range (( y + 1 ) % 2 , 8 , 2 ) ] white_pieces = [ Piece ( 'white' , ( x , y )) for y in range ( 5 , 8 ) for x in range (( y + 1 ) % 2 , 8 , 2 ) ] return GameState ( black_pieces + white_pieces ) def game ( request ): game_state = GameState . new_game () return render ( request , 'game.html' , {}) Create games/templates/game.html as follows: <!doctype html> < html > < head > < title > Draughts </ title > < script > document . addEventListener ( 'DOMContentLoaded' , event => { const gameElement = document . getElementById ( 'game' ); gameElement . innerHTML = 'TODO: render the board here' }); </ script > </ head > < body > < h1 > Draughts </ h1 > < div id = \"game\" > </ div > </ body > </ html > Add the new view to draughts/urls.py : from django.contrib import admin from django.urls import path from games.views import game urlpatterns = [ path ( '' , game ), path ( 'admin/' , admin . site . urls ), ] Now start the server with ./manage.py runserver and visit http://localhost:8000/ . So far we've created a GameState object representing a new game - it's now time to introduce telepath, so that we can transfer that object to the client. Run: pip install telepath and add 'telepath', to the INSTALLED_APPS list in draughts/settings.py . Now edit games/views.py : import json from django.shortcuts import render from telepath import JSContext # ... def game ( request ): game_state = GameState . new_game () js_context = JSContext () packed_game_state = js_context . pack ( game_state ) game_state_json = json . dumps ( packed_game_state ) return render ( request , 'game.html' , { 'game_state_json' : game_state_json , }) Here JSContext is a helper that manages the conversion of our game state object into a representation we can use in Javascript. js_context.pack takes that object and converts it to a value that can be JSON-serialised and passed to our template. However, reloading the page now fails with an error of the form: don't know how to pack object: <games.views.GameState object at 0x10f3f2490> This is because GameState is a custom Python type that telepath does not yet know how to handle. Any custom type passed to pack must be linked to a corresponding JavaScript implementation; this is done by defining a telepath_pack method and registering the class with telepath. Update games/views.py as follows: import json from django.shortcuts import render from telepath import JSContext , register # ... @register class GameState : def __init__ ( self , pieces ): self . pieces = pieces @staticmethod def new_game (): black_pieces = [ Piece ( 'black' , ( x , y )) for y in range ( 0 , 3 ) for x in range (( y + 1 ) % 2 , 8 , 2 ) ] white_pieces = [ Piece ( 'white' , ( x , y )) for y in range ( 5 , 8 ) for x in range (( y + 1 ) % 2 , 8 , 2 ) ] return GameState ( black_pieces + white_pieces ) def telepath_pack ( self , context ): context . add_media ( js = 'draughts.js' ) return ( 'draughts.GameState' , [ self . pieces ]) Here the telepath_pack method tells telepath how to 'deconstruct' the game_state object so that it can be reconstructed on the client side as a JavaScript object. 'draughts.GameState' is an identifier for a JavaScript constructor function that we will define later on; this is followed by a list of arguments that will be passed to this constructor function, which in this case is a single argument, the list of Piece objects. The line context.add_media(js='draughts.js']) tells telepath that the JavaScript implementation of GameState can be found in the file draughts.js . We'll see what this JavaScript implementation looks like later - for now, we need to add a similar definition for our Piece class, since our definition of GameState.telepath_pack is dependent on being able to pack Piece instances. In games/views.py : @register class Piece : def __init__ ( self , color , position ): self . color = color self . position = position def telepath_pack ( self , context ): context . add_media ( js = 'draughts.js' ) return ( 'draughts.Piece' , [ self . color , self . position ]) Reload the page and you'll see that the error has gone, indicating that we have successfully serialised the GameState object to JSON and passed it to the template. We can now include this in the template - edit games/templates/game.html : < body > < h1 > Draughts </ h1 > < div id = \"game\" data-game-state = \"{{ game_state_json }}\" > </ div > </ body > Reload the page again and inspect the game element in your browser's developer tools (in Chrome and Firefox, right-click the TODO note and select Inspect or Inspect Element), and you'll see the JSON representation of the GameState object, ready to be unpacked into a full-fledged JavaScript object. Along with packing data into JSON-serialisable form, the JSContext object also keeps track of the JavaScript media definitions that will be needed to unpack the data, as its media property. Let's update our game view to pass this to the template too - in games/views.py : def game ( request ): game_state = GameState . new_game () js_context = JSContext () packed_game_state = js_context . pack ( game_state ) game_state_json = json . dumps ( packed_game_state ) return render ( request , 'game.html' , { 'game_state_json' : game_state_json , 'media' : js_context . media , }) Add this to the HTML header in games/templates/game.html : < head > < title > Draughts </ title > {{ media }} < script > document . addEventListener ( 'DOMContentLoaded' , event => { const gameElement = document . getElementById ( 'game' ); gameElement . innerHTML = 'TODO: render the board here' }); </ script > </ head > Reloading the page and viewing source, you'll see that this brings in two JavaScript includes - telepath.js (the client-side telepath library, which provides the unpacking mechanism) and the draughts.js file we specified in our telepath_pack methods. The latter doesn't exist yet, so let's create it - in games/static/draughts.js : class Piece { constructor ( color , position ) { this . color = color ; this . position = position ; } } window . telepath . register ( 'draughts.Piece' , Piece ); class GameState { constructor ( pieces ) { this . pieces = pieces ; } } window . telepath . register ( 'draughts.GameState' , GameState ); The two class definitions implement the constructor functions that we declared earlier in the telepath_pack methods - the arguments received by the constructor match the ones we supplied in the pack method. The window.telepath.register lines attach these class definitions to the corresponding identifiers that were specified through js_constructor . This now gives us everything we need to unpack the JSON - back in games/templates/game.html , update the JS code as follows: < script > document . addEventListener ( 'DOMContentLoaded' , event => { const gameElement = document . getElementById ( 'game' ); const gameStateJson = gameElement . dataset . gameState ; const packedGameState = JSON . parse ( gameStateJson ); const gameState = window . telepath . unpack ( packedGameState ); console . log ( gameState ); }) </ script > You may need to restart the server to pick up the new games/static folder. Reload the page, and in the browser console you should now see the GameState object, populated with Piece objects. We can now proceed to fill in our rendering code in games/static/draughts.js : class Piece { constructor ( color , position ) { this . color = color ; this . position = position ; } render ( container ) { const element = document . createElement ( 'div' ); container . appendChild ( element ); element . style . width = element . style . height = '24px' ; element . style . border = '2px solid grey' ; element . style . borderRadius = '14px' ; element . style . backgroundColor = this . color ; } } window . telepath . register ( 'draughts.Piece' , Piece ) class GameState { constructor ( pieces ) { this . pieces = pieces ; } render ( container ) { const table = document . createElement ( 'table' ); container . appendChild ( table ); const cells = []; for ( let y = 0 ; y < 8 ; y ++ ) { let row = document . createElement ( 'tr' ); table . appendChild ( row ); cells [ y ] = []; for ( let x = 0 ; x < 8 ; x ++ ) { let cell = document . createElement ( 'td' ); row . appendChild ( cell ); cells [ y ][ x ] = cell ; cell . style . width = cell . style . height = '32px' ; cell . style . backgroundColor = ( x + y ) % 2 ? 'silver' : 'white' ; } } this . pieces . forEach ( piece => { const [ x , y ] = piece . position ; const cell = cells [ y ][ x ]; piece . render ( cell ); }); } } window . telepath . register ( 'draughts.GameState' , GameState ) Add a call to the render method in games/templates/game.html : < script > document . addEventListener ( 'DOMContentLoaded' , event => { const gameElement = document . getElementById ( 'game' ); const gameStateJson = gameElement . dataset . gameState ; const packedGameState = JSON . parse ( gameStateJson ); const gameState = window . telepath . unpack ( packedGameState ); gameState . render ( gameElement ); }) </ script > Reload the page, and you'll see our draughts board set up and ready for a game. Let's take a quick look back at what we've achieved: We've packed and unpacked a data structure of custom Python / JavaScript types, without having to write code to recurse over that structure. If our GameState object becomes more complex (for example, the 'pieces' list might become a mixed list of Piece and King objects, or the state could include the game history) then there's no need to refactor any of the data packing / unpacking logic, other than registering each class with a telepath_pack method. Only the JS files necessary for unpacking the on-page data were served - if our gaming app expanded to cover Chess, Go and Othello, with all of the resulting classes registered with telepath, we'd still only need to serve the draughts-related code on this page. Even though we're working with arbitrary objects, no dynamic inline JavaScript was required - all dynamic data was passed as JSON, and all JavaScript code was fixed at deployment time (important if our site is enforcing CSP ).","title":"Tutorial"}]}